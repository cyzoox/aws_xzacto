# @model: Creates a DynamoDB table for the type and CRUD operations in the GraphQL API
# @auth: Defines the authorization rules for the type

type Staff @model @auth(rules: [{ allow: public }]) {
  id: ID!
  name: String!
  password: String!
  ownerId: ID
  accountId: ID
  role: [String!]!
  log_status: String
  device_id: String
  device_name: String
  stores: [Store] @manyToMany(relationName: "StaffStore")
  transactions: [SaleTransaction] @hasMany(fields: ["id"])
  cartItems: [CartItem] @hasMany(fields: ["id"])
  account: Account @belongsTo(fields: ["accountId"])
}

type Category @model @auth(rules: [{ allow: public }]) {
  id: ID!
  name: String!
  storeId: ID!
  store: Store @belongsTo(fields: ["storeId"])
  products: [Product] @hasMany(fields: ["id"])
}

type WarehouseProduct @model @auth(rules: [{allow: public}]) {
  id: ID!
  name: String!
  brand: String
  description: String
  purchasePrice: Float!
  sellingPrice: Float!
  totalStock: Float!
  availableStock: Float!
  sku: String!
  barcode: String
  img: String
  category: String
  subcategory: String
  supplier: String
  supplierContact: String
  reorderPoint: Float
  reorderQuantity: Float
  location: String
  isActive: Boolean!
  lastRestockDate: AWSDateTime
  storeProducts: [Product] @hasMany(fields: ["id"])
  requestItems: [RequestItem] @hasMany(fields: ["id"])
}

type Product @model @auth(rules: [{allow: public}]) {
  id: ID!
  name: String!
  brand: String
  description: String
  oprice: Float!
  sprice: Float!
  stock: Float
  categoryId: ID
  subcategory: String
  sku: String
  img: String
  storeId: ID!
  warehouseProductId: ID
  addons: [Addon] @hasMany(fields: ["id"])
  variants: [Variant] @hasMany(fields: ["id"])
  isActive: Boolean!
  store: Store @belongsTo(fields: ["storeId"])
  category: Category @belongsTo(fields: ["categoryId"])
  warehouseProduct: WarehouseProduct @belongsTo(fields: ["warehouseProductId"])
  cartItems: [CartItem] @hasMany(fields: ["id"])
  sales: [Sale] @hasMany(fields: ["id"])
}

type Store @model @auth(rules: [{ allow: public }]) {
  id: ID!
  name: String!
  location: String!
  ownerId: ID
  accountId: ID
  products: [Product] @hasMany(fields: ["id"])
  categories: [Category] @hasMany(fields: ["id"])
  staff: [Staff] @manyToMany(relationName: "StaffStore")
  transactions: [SaleTransaction] @hasMany(fields: ["id"])
  expenses: [Expense] @hasMany(fields: ["id"])
  customers: [Customer] @hasMany(fields: ["id"])
  suppliers: [Supplier] @hasMany(fields: ["id"])
  cartItems: [CartItem] @hasMany(fields: ["id"])
  inventoryRequests: [InventoryRequest] @hasMany(fields: ["id"])
  account: Account @belongsTo(fields: ["accountId"])
}

type SaleTransaction @model @auth(rules: [{ allow: public }]) {
  id: ID!
  items: [String!]!
  total: Float!
  discount: Float
  points: Float
  staffID: ID!
  staffName: String
  storeID: ID!
  customerID: ID
  ownerId: ID
  status: String
  payment_status: String
  cash_received: Float
  paymentMethod: String
  change: Float
  notes: String
  staff: Staff @belongsTo(fields: ["staffID"])
  store: Store @belongsTo(fields: ["storeID"])
  customer: Customer @belongsTo(fields: ["customerID"])
  sales: [Sale] @hasMany(fields: ["id"])
}

type Sale @model @auth(rules: [{ allow: public }]) {
  id: ID!
  productID: ID!
  productName: String
  transactionID: ID!
  price: Float!
  quantity: Int!
  discount: Float
  total: Float!
  status: String!
  ownerId: ID
  product: Product @belongsTo(fields: ["productID"])
  transaction: SaleTransaction @belongsTo(fields: ["transactionID"])
  void_reason: String
  variantData: AWSJSON
  addonData: AWSJSON
}

type CreditTransaction @model @auth(rules: [{allow: public}]) {
  id: ID!
  customerID: ID!
  amount: Float!
  type: String
  remarks: String
  createdAt: AWSDateTime
  addedBy: String # Optional - name or ID of staff who added credit
  customer: Customer @belongsTo(fields: ["customerID"])
}


type Addon @model @auth(rules: [{ allow: public }]) {
  id: ID!
  name: String!
  price: Float!
  productId: ID!
  product: Product @belongsTo(fields: ["productId"])
}

type Variant @model @auth(rules: [{ allow: public }]) {
  id: ID!
  name: String!
  price: Float!
  productId: ID!
  product: Product @belongsTo(fields: ["productId"])
}

type Customer @model @auth(rules: [{allow: public}]) {
  id: ID!
  name: String!
  email: AWSEmail
  phone: AWSPhone
  storeId: ID!
  ownerId: ID
  points: Float
  creditBalance: Float      # Prepaid credits
  allowCredit: Boolean    # Can they use postpaid credit?
  creditLimit: Float
  purchases: [SaleTransaction] @hasMany(fields: ["id"])
  store: Store @belongsTo(fields: ["storeId"])
  creditTransactions: [CreditTransaction] @hasMany(fields: ["id"])
}

type Supplier @model @auth(rules: [{ allow: public }]) {
  id: ID!
  name: String!
  email: AWSEmail
  phone: AWSPhone
  storeId: ID!
  products: [Product] @hasMany(fields: ["id"])
  store: Store @belongsTo(fields: ["storeId"])
}

type Expense @model @auth(rules: [{ allow: public }]) {
  id: ID!
  name: String!
  amount: Float!
  date: AWSDateTime!
  storeId: ID!
  staffId: ID
  staffName: String
  ownerId: ID
  category: String
  notes: String
  store: Store @belongsTo(fields: ["storeId"])
}

type CartItem @model @auth(rules: [{ allow: public }]) {
  id: ID!
  name: String!
  brand: String
  oprice: Float!
  sprice: Float!
  productId: ID!
  cashierId: ID!
  category: String
  unit: String
  storeId: ID!
  quantity: Int!
  
  # Using AWSJSON for variant and addon data
  variantData: AWSJSON
  addonData: AWSJSON
  
  # Legacy field for backward compatibility
  addon: String
  
  store: Store @belongsTo(fields: ["storeId"])
  product: Product @belongsTo(fields: ["productId"])
  staff: Staff @belongsTo(fields: ["cashierId"])
}

type InventoryRequest @model @auth(rules: [{ allow: public }]) {
  id: ID!
  storeId: ID!
  status: String!
  requestDate: AWSDateTime!
  fulfillmentDate: AWSDateTime
  requestedBy: ID!
  processedBy: ID
  ownerId: ID
  priority: String!
  notes: String
  store: Store @belongsTo(fields: ["storeId"])
  requestItems: [RequestItem] @hasMany(fields: ["id"])
}

type RequestItem @model @auth(rules: [{ allow: public }]) {
  id: ID!
  requestId: ID!
  warehouseProductId: ID!
  requestedQuantity: Float!
  fulfilledQuantity: Float
  status: String!
  inventoryRequest: InventoryRequest @belongsTo(fields: ["requestId"])
  warehouseProduct: WarehouseProduct @belongsTo(fields: ["warehouseProductId"])
}

# Subscription plan type to track subscription details
type SubscriptionPlan @model @auth(rules: [{ allow: public }]) {
  id: ID!
  name: String!
  description: String
  price: Float!
  interval: String!  # monthly, yearly, etc.
  storeLimit: Int!   # maximum number of stores allowed
  staffPerStoreLimit: Int! # maximum staff per store
  adminPerStoreLimit: Int! # maximum admins per store
  features: [String]  # array of enabled features
  isActive: Boolean!
  accounts: [Account] @hasMany(fields: ["id"])
}

# Account type to track subscription and ownership
type Account @model @auth(rules: [{ allow: public }]) {
  id: ID!
  ownerId: ID!       # links to the Auth user ID
  ownerEmail: String!
  subscriptionPlanId: ID!
  subscriptionStatus: String! # active, canceled, trial, etc.
  subscriptionStartDate: AWSDateTime!
  subscriptionEndDate: AWSDateTime
  lastModifiedBy: String     # tracks which user modified the subscription
  stores: [Store] @hasMany(fields: ["id"])
  staff: [Staff] @hasMany(fields: ["id"])
  subscriptionPlan: SubscriptionPlan @belongsTo(fields: ["subscriptionPlanId"])
  subscriptionHistory: [SubscriptionHistory] @hasMany(fields: ["id"])
}

# Add a type for subscription change history
type SubscriptionHistory @model @auth(rules: [{ allow: public }]) {
  id: ID!
  accountId: ID!
  changeDate: AWSDateTime!
  changedBy: String!   # staff ID who made the change
  previousPlanId: ID
  newPlanId: ID!
  account: Account @belongsTo(fields: ["accountId"])
}